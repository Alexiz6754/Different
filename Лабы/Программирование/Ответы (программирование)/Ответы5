
Коллекции. Сортировка элементов коллекции. Интерфейсы java.util.Comparable и java.util.Comparator.

Comparable интерфейс, который определяет метод compare() позволяющий сортировать элементы коллекции по умолчанию
Comparator интерфейс, который определяет метод compareTo() позволяющий сравнивать два элемента коллекции в методе сортировки
------------
Категории коллекций - списки, множества. Интерфейс java.util.Map и его реализации.

HashMap,SortedMap,NavigableMap,TreeMap
-------------
Параметризованные типы. Создание параметризуемых классов. Wildcard-параметры.

Параметризованные типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра
Wildcard-параметры нужны для типобезопасности при использовании дженериков (extends - ограничение сверху, super - ограничение снизу)
------------------------
Классы-оболочки. Назначение, область применения, преимущества и недостатки. Автоупаковка и автораспаковка.

Double,Integer,Long... нужны для удобной работы с примитивами, а также с возможностью представлять примитивы в виде объектов
Автоупаковка/автораспаковка - возможность приводить примитивы к оболочкам "на лету"
-------------------------
Потоки ввода-вывода в Java. Байтовые и символьные потоки. "Цепочки" потоков (Stream Chains).

Байтовые - читают/пишут байты (InputStream/OutputStream)
Символьнаые - читают/пишут символы (Reader/Writer)

Для ускорения работы и удобства используется буфферный ввод/вывод. Работа быстрее, так как не приходится постоянно обращаться к устройству ввода (Данные просто читаются из буфера, как только мы дошли до его конца, то подтягивается следующая порция)
-----------------------------
Работа с файлами в Java. Класс java.io.File.

---------------
Пакет java.nio - назначение, основные классы и интерфейсы.

Подход, на котором основан Java NIO немного отличается от Java IO. Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.

Блокирующий и неблокирующий ввод/вывод

Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.

Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.

Каналы (channels)
Каналы – это логические (не физические) порталы, через которые осуществляется ввод/вывод данных, а буферы являются источниками или приёмниками этих переданных данных. При организации вывода, данные, которые вы хотите отправить, помещаются в буфер, а он передается в канал. При вводе, данные из канала помещаются в предоставленный вами буфер.

Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов. Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.

Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.

Таким образом неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. Наиболее частой практикой является использование сэкономленного времени работы потока выполнения на обслуживание операций ввода/вывода в другом или других каналах.

Селекторы

Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

Чтобы лучше понять концепцию и выгоду от применения селекторов, давайте абстрагируемся от программирования и представим себе железнодорожный вокзал. Вариант без селектора: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.

--------------
Утилита javadoc. Особенности автоматического документирования кода в Java.

Позволяет генерировать документацию из комментариев в HTML формате, имеет свои дескрипторы, которые позволяют оформить документацию
--------------
